## 一、改造二叉搜索树

普通的二叉搜索树，在执行例如select * from table where id > 12的sql语句的时候，会遇到范围查询查到一个叶子节点，还需要回到父节点去遍历其他值的问题，并不能直接高效的把所有值查出来。

![image-20220113080827918](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220113080827918.png)

但如果我们把二叉搜索树改造成如下模样，把所有节点都在叶子节点上存储一份，那么就只需要直接遍历叶子节点，就可以拿到所有的范围数据了。





![image-20220113080750700](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220113080750700.png)

那么是不是以上结构就可以直接作为数据库sql查询的索引了呢？并不是，以上结构是二叉的，会存在树高度过高的问题，而数据库索引都是存在硬盘里的，从而导致磁盘IO损耗过大，这是我们所不能接受的，从而就引出了我们的B+Tree

## 二、B+Tree

### 1、B+Tree的性质

 对于一个M阶的B+Tree多叉树，存在着如下的性质：

（1）每个节点最多有m个子节点，也就是m阶：这个由磁盘的页面大小决定，磁盘块和页内存一般都是4KB。我们的节点数也就是我们的m值，应该要尽可能的跟他一样，因为一次读取这么多。比如0.75的原则HashMap就是如此。这样的好处就是为了我们一次刚好能全部拿出一个节点里面存的所有的数据。

（2）除根节点外，每个节点至少有m/2个子节点，注意如果结果除不尽，就向上取整，比如5/2=3。 3/2=ceil(1.5)=2

（3）根节点要么是空，要么是独根，否则至少有2个子节点

（4）有k个子节点的节点必有k个关键码:就是 有m个数据就有m个叉叉；

（5）叶节点的高度一致：保证了数据库sql查询性能的稳定性



### 2、构建一个B+Tree的过程

![image-20220113081412249](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220113081412249.png)

### 3、B+Tree在Mysql中的分析

B+Tree这个阶数很重要直接决定了B+Tree的查找效率以及性能，那么在Mysql中我们如何设定这阶数呢？

通过mysql的页大小决定，一般是16k。那么一个主键类型为bigint的字段建索引大约的消耗空间是多少呢？

Int：8字节（4+4），指针一个也算4字节。

一页的节点：16kb/ (8b+8b)=1k 键值+指针

我们刚举例的3阶B+Tree即可以存下1024\*1024\*1024也就是10亿的数据

可想而知如果在理想情况下 ，我们的mysql查询是很高效的，一般最多也就4阶左右的B+Tree。

### 4、如何正确建立索引

1.索引不能太多，因为B+tree的插入和删除是要维护的，太多的索引会导致插入变慢。

2.建了索引的字段不能使用like ‘%%’否则是失效的。

3.建索引的字段类型不能太大，字段越小阶数就越大，效率就越高，int 和 bigint，varchar（10），varchar（100）。text，lontext应该建立全文索引。

4.建索引的字段值不能太多一样的，也就是索引的离散值（区分度）要大，比如我们把性别建索引会出现啥情况？左边都是一样的值，导致过滤不了一半（0,1）。

5.联合索引的最左匹配原则。

Select * from user where name = ‘赵云’ and id = 1 。可以匹配到（ id,name) 建的索引，mysql解析的时候会自动优化。

Select * from user where name = ‘赵云’ and age=10则不能匹配到（ id,name,age) 建的索引

6.NOT IN 是不会走索引的 not in (1,2,3)，当然in的值太多，mysql会报错的，是有一个上限值的。

## 三、B-Tree和B+Tree的区别

1.B-tree所有的节点都会存数据：导致查询效率的不稳定

2.b-tree叶子节点没有链表，B+Tree数据存储在叶子节点构成的双向链表上。

我们认为b-tree是b+tree的过度。

## 四、二叉查找树，红黑树，B-Tree，B+Tree 的区别

1.二叉查找树：二叉搜索树，优点查找快，但是在某些情况下会退化成链表，它是所有高效查找树的基础，如果不懂这个，其他的也学不懂。这是最根本性的东西，最好能自己手写出来。

2.红黑树：内存查找高效树，不适合大数据量，也不适合磁盘存储的。具体的分析就是IO浪费以及读取资源浪费，还有就是树的深度会很大。适合一些底层系统做内存运算、

3.B-Tree：可以认为是B+Tree过度。只需要知道BTree就可以

4.B+Tree：最适合大数据的磁盘索引，经典的MySql，所有的数据都存在叶子节点。其他都是索引，增加了系统的稳定性以及遍历以及查找效率。



