/**
 * 调用的全过程详细分析:
 * int dp[][] = new int[4][51]
 * <p>
 * i = 1 ,     // 自上而下循环，如果能装不进来就取上方的值，如果能装进来就比较value + 和上方的值的最大值
 * // 需要满足cw >=10
 * cw=8,dp[1][8] = dp[0][8] = 0
 * cw=9,dp[1][9] = dp[0][9] = 0
 * cw=10,dp[1][10] = max(60 + dp[0][10-10], dp[0][10]) = max(60,0) = 60
 * cw = 11,dp[1][11] = max(60 + dp[0][11-10],dp[0][11]) = max(60,0) = 60
 * cw = 29,dp[1][29] = max(60 + dp[0][29-10],dp[0][29]) = max(60,0) = 60
 * cw = 30,dp[1][30] = max(60 + dp[0][30-10],dp[0][30]) = max(60,0) = 60
 * cw = 50,dp[1][50] = max(60 + dp[0][50-10],dp[0][30]) = max(60,0) = 60
 * <p>
 * i = 2,
 * // 需要满足cw >=20
 * cw=8,dp[2][8] = dp[1][8] = 0
 * // 在重量达到cw = 20之前，没有必要比较max，直接继承上方的值
 * cw=10,dp[2][10] = dp[1][10] = 60
 * // dp[i-1][cw-weigth[i-1]]，因为20进来已经装满，下一次有意义的比较是在上一层的cw处，所以在这边20-20回到上一层的首位
 * // 下一次有意义的比较,是在当前cw的基础上 + 上一层的cw值weight[i-1]处
 * cw=20,dp[2][20] = max(100 + dp[1][20-20], dp[1][20]) = max(100,60) = 100
 * cw= 30,dp[2][30] = max(100 + dp[1][30-20]),dp[1][30]) = max(100+60,60) = 160
 * cw= 50,dp[2][50] = max(100 + dp[1][50-20]),dp[1][50]) = max(100+60,60) = 160
 * <p>
 * i = 3,
 * // 需要满足cw >=40，即：在重量达到cw = 40之前，没有必要比较max，直接继承上方的值
 * cw=8,dp[3][8] = dp[2][8] = 0
 * cw=10,dp[3][10] = dp[2][10] = 60
 * cw=20,dp[3][20] = dp[2][20] = 100
 * cw=30,dp[3][30] = dp[2][30] = 160
 * cw=40,dp[3][40] = max(120 + dp[2][40-40],dp[2][40]) = max(120,160) = 160
 * // 自下而上是一个递归继承关系，cw需要至少等于当前的cw + 上几层中最小的cw时，才有进行max判断的意义
 * // 如果不满足这个条件，也会进行max判断，只是效果和cw=40时的效果完全相同
 * cw=50,dp[3][50] = max(120 + dp[2][50-40],dp[2][50]) = max(120+60,160) = 180
 * <p>
 * // 至此循环调用完毕
 */
public class Dp {

    public static void main(String[] args) {

        // 单位价值
        int value[] = {60, 100, 120};
        // 单位重量
        int weigth[] = {10, 20, 40};


        int w = 50;
        int n = 3;
        // dp[n][cw]  n代表当前物品序号,所以初始化得n+1,cw代表当前重量,初始化也得w+1
        int dp[][] = new int[n + 1][w + 1];        //n表示是物品，w表示重量,初始化全是0

        for (int i = 1; i <= n; i++) {    //每次加的物品
            for (int cw = 1; cw <= w; cw++) {        //分割的背包
                if (weigth[i - 1] <= cw) {        //表示这个物品可以装进去
                    dp[i][cw] = Math.max(
                            value[i - 1] + dp[i - 1][cw - weigth[i - 1]],
                            dp[i - 1][cw]
                    );
                } else {
                    dp[i][cw] = dp[i - 1][cw];    //不能装
                }
            }
        }
        System.out.println(dp[n][w]);

    }
}
