## 一、二叉搜索树（二叉排序树）

二叉搜索树又叫二叉查找树，二叉排序树；它具有以下特点：

1.如果它的左子树不为空，则左子树上结点的值都小于根结点。

2.如果它的右子树不为空，则右子树上结点的值都大于根结点。

3.子树同样也要遵循以上两点

为什么又叫做二叉排序树呢？ 二叉树的遍历方式分为：前 中 后 层次遍历（Mysql）

只要一颗树是二叉搜索树，那么它的中序遍历一定是有序的，遍历顺序：左、根（输出）、右

看下边的这颗二叉树，它的中序遍历为：左根右

左 根（输出） 右：0 3 4 5 6 8

![image-20220104025950764](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220104025950764.png)

## 二、二叉搜索树的增删改查

1.查找的时候每次都是和根节点比较，一直找到对应的节点值为止。查找的时间复杂度：log(n)

2.插入的时候每次都是和根结点比较。一直要找到它应该插入的位置。插入一定肯定会插在叶子结点。那么其实可以看到，插入其实就是查找。插入n个节点的时间复杂度：nlog(n)

3.删除是要分三种情况，

+ 要删除的结点是叶子结点，查找到后直接删除即可，时间复杂度: O(1)

+ 要删除的结点只有一个子树（左或者右），直接删除后移动子节点指针，时间复杂度：O(1)

+ 要删除的结点有两颗子树：这时候需要找目标节点的后继结点，用后继节点和目标节点做交换，其中找到的后继结点的左子树一定为空，因为找后继节点的过程需要遍历整棵树，所以时间复杂度增长到：O(log(n))

补充知识：

+ 后继节点：节点右分支下第一个比根节点大的数(大的差值的最小)，或者可以理解成中序遍历下的下一个值

+ 前继节点：节点左分支下第一个比根节点小的数(小的差值的最小)，或者可以理解成中序遍历下的上一个值

## 三、二叉搜索树的特点

![image-20220109021231710](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220109021231710.png)

如果一颗二叉搜索树是上图形式，那它就意味着退化成了链表，遍历它的时间复杂度也级从O(log(n))退化成了O(n)，为了克服这种问题，我们需要对树进行"整型"，让他的左右两端高度维持一个我们可以接受的差值。

平衡二叉树(平衡二叉搜索树)就是为了克服这个弊端而诞生的，通过平衡左右两端的高度，使树的总高度尽可能的低，从而最大化降低整棵树的时间复杂度。

理论上的平衡二叉树，也就是绝对的平衡二叉树，叫AVL树，它的左右层数相差在1以内，但是为了维持这一高度差，需要在整形上付出的时间复杂度代价过大，所以实际实现上我们一般用的多的是非绝对平衡的二叉树——红黑树。

## 四、红黑树

![image-20220109033049889](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220109033049889.png)

红黑树的： 对二叉查找树做了类平衡操作后的红黑树

红黑树必须要满足以下性质：

+ 1.每个结点不是红色就是黑色

+ 2.不可能有连在一起的红色结点（黑色的就可以），每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据

+ 3.根结点都是黑色 root

+ 4.每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

并且在实际实现上往往会增加更多的限制，比如要求子链上的红色节点数量不能超过2个、左右子链相差的红色节点数量不能超过2个等条件来进一步限制红黑树的高度。

## 五、红黑树的变色与旋转

为了满足红黑树的性质，因此出现了红黑树的变换。

一共有以下3种变换：

+ 1.改变颜色：这是最简单的，红变黑，黑变红。

+ 2.左旋：针对某个点做旋转，要注意的是旋转点下面的子树也要跟着转，也就是父变子，子变父，指针跟着转。

+ 3.右旋：除方向外其他同左旋。

![image-20220109044534530](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220109044534530.png)

那么我们又该如何选择以上三种方式呢？

## 六、红黑树的变换规则

![image-20220109044703459](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220109044703459.png)

插入：（新加入的点一定要是红色，如果所有节点为黑色，那么红黑树就退化成了二叉查找树）

1.变颜色的情况：当前结点的父亲是红色，且它的祖父结点（爷爷）的另一个子结点（叔叔）也是红色。

（1）把父节点设为黑色

（2）把叔叔也设为黑色

（3）把祖父也就是父亲的父亲设为红色（爷爷）

（4）把指针定义到祖父结点(爷爷)设为当前要操作的

2.左旋：当前父结点是红色，叔叔是黑色的时候，且当前的结点是右子树。左旋以父结点作为左旋。指针变换到父亲结点。

3.右旋：当前父结点是红色，叔叔是黑色的时候，且当前的结点是左子树。右旋以祖父结点旋转。

（1）把父结点变为黑色

（2）把祖父结点变为红色 （爷爷）

（3）以祖父结点旋转（爷爷）



删除：较为复杂，待整理补充

## 七、红黑树的性能分析

插入的时间复杂度:  近似O(nlog(n))

查找的时间复杂度：O(log(n))

删除的时间复杂度：近似O(log(n))

## 八、红黑树的应用

1.HashMap(jdk8)

2.TreeMap

3.Windows底层：查找

4.Linux进程调度，nginx等